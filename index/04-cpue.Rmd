# Commercial CPUE

```{r cpue-read-historic}
if (!file.exists(here::here("data/historic-cpue-raw-data.rds"))) {
  d <- gfplot::get_cpue_historic(species = NULL, end_year = 2017)
  readr::write_rds(d, here::here("data/historic-cpue-raw-data.rds"))
} else {
  d <- readr::read_rds(here::here("data/historic-cpue-raw-data.rds"))
}
# make 'year' column mean 'fishing year'
d$year <- NULL
d$year <- d$alt_year
d$alt_year <- NULL
d$target_species <- NULL
```

We will start by removing all fishing events that have NAs for hours fished,
catch, or depth. We will also remove all fishing events that have hours fished,
catch, or depth less than zero.

```{r cpue-basic-filter}
# Basic filters that will apply to all data sets:
d <- d %>% filter(!is.na(hours_fished), !is.na(total), !is.na(best_depth_m),
    best_depth_m > 0, hours_fished > 0, total > 0, year >= 1956, year <= 1995)
```

```{r cpue-historic-basic-filtering}
key_locality <- c(
  "cape scott spit",
  "mexicana",
  "topknot",
  "ne goose",
  "se goose",
  "nw goose",
  "sw goose",
  "reef island",
  "west horseshoe",
  "east horseshoe",
  "two peaks",
  "butterworth",
  "white rocks",
  "shell ground"
  )

# Suggested by Paul Starr by email in 2018:
new_locality_2018 <-
  c("triangle", "ole spot", "north moresby", "south bonilla", "west two peaks")

# Make sure we have spelled all the localities correctly:
stopifnot(all(key_locality %in% unique(d$locality_description)))
stopifnot(all(new_locality_2018 %in% unique(d$locality_description)))
```

We will reproduce the key localities analysis from REF. The key localities used
in that assessment were `r paste(key_locality, collapse = ", ")`. We will also
try including the additional localities `r paste(new_locality_2018, collapse = ", ")`.

The previous assessment used a depth threshold of 150m for the calculation of
commercial CPUE. A substantial portion of the Pacific Cod fishing events are at
depths deeper than 150m (Figure \@ref(fig:cpue-historic-depth)). Therefore, we
created a commercial CPUE data set with an alternative threshold of 350m to
encapsulate the vast majority of Pacific Cod fishing events.

```{r cpue-historic-depth, out.width="4in", fig.width=5, fig.cap="Depth distribution across all fishing events that caught Pacific Cod."}
# Look at the depth distribution:
filter(d, species_code == "222") %>%
  group_by(year, fishing_event_id) %>%
  summarise(best_depth_m = best_depth_m[[1]]) %>%
  ggplot(aes(best_depth_m)) +
  geom_histogram(binwidth = 12) +
  geom_vline(xintercept = 150, lty = 2) +
  geom_vline(xintercept = 25, lty = 2) +
  geom_vline(xintercept = 350, lty = 2) +
  scale_x_continuous(breaks = c(0, 150, 350, 500, 750), limits = c(0, 760)) +
  ylim(0, NA) +
  coord_cartesian(expand = FALSE) +
  theme_pbs()
```

```{r cpue-historic-data-binding}
# This is to create 3CD, 5AB, 5CD, and 5ABCD versions of the data:
d3cd <- filter(d, area %in% c("3CD"))
d5ab <- filter(d, area %in% c("5AB"))
d5cd <- filter(d, specific_area %in% c("5C", "5D"))
d5cd$area <- "5CD"
d5abcd <- bind_rows(d5ab, d5cd)
d5abcd$area <- "5ABCD"
d_all <- bind_rows(d3cd, d5ab, d5cd, d5abcd)
rm(d3cd, d5ab, d5cd, d5abcd)
```

```{r cpue-historic-calculations}
# A data set with the original key localities:
d_loc <- d_all %>%
  filter(locality_description %in% key_locality |
      (year <= 1967 & (specific_area == "5A" | specific_area == "5B")) |
      area == "3CD")

# This should match CPUE analysis D from the last research document:
d_resdoc_2015 <- d_loc %>%
  filter(best_depth_m <= 150, best_depth_m >= 25) %>%
  group_by(year, area, trip_id, fishing_event_id) %>%
  summarise(
    pcod_catch = sum(ifelse(species_code == "222", total, 0)),
    effort = hours_fished[[1]]) %>%
  group_by(area, year) %>%
  summarise(pcod_catch = sum(pcod_catch), effort = sum(effort)) %>%
  mutate(cpue = pcod_catch / effort) %>%
  mutate(version = "Forrest et al. 2015 reconstruction")

# This version extends the depth filter to 300m, which encompasses most but
# not all Pacific Cod:
d_depth_350 <- d_loc %>%
  filter(best_depth_m <= 350) %>%
  group_by(year, area, trip_id, fishing_event_id) %>%
  summarise(
    pcod_catch = sum(ifelse(species_code == "222", total, 0)),
    effort = hours_fished[[1]]) %>%
  group_by(area, year) %>%
  summarise(pcod_catch = sum(pcod_catch), effort = sum(effort)) %>%
  mutate(cpue = pcod_catch / effort) %>%
  mutate(version = "Depth <= 350")

# This version adds in the key localities only:
d_depth_new_loc <- d_all %>%
  filter(locality_description %in% union(new_locality_2018, key_locality) |
      (year <= 1967 & (specific_area == "5A" | specific_area == "5B")) |
      area == "3CD") %>%
  filter(best_depth_m <= 150) %>%
  group_by(year, area, trip_id, fishing_event_id) %>%
  summarise(
    pcod_catch = sum(ifelse(species_code == "222", total, 0)),
    effort = hours_fished[[1]]) %>%
  group_by(area, year) %>%
  summarise(pcod_catch = sum(pcod_catch), effort = sum(effort)) %>%
  mutate(cpue = pcod_catch / effort) %>%
  mutate(version = "New localities")

# This version adds in the new key localities and new depth:
d_depth_350_new_loc <- d_all %>%
  filter(locality_description %in% union(new_locality_2018, key_locality) |
      (year <= 1967 & (specific_area == "5A" | specific_area == "5B")) |
      area == "3CD") %>%
  filter(best_depth_m <= 350) %>%
  group_by(year, area, trip_id, fishing_event_id) %>%
  summarise(
    pcod_catch = sum(ifelse(species_code == "222", total, 0)),
    effort = hours_fished[[1]]) %>%
  group_by(area, year) %>%
  summarise(pcod_catch = sum(pcod_catch), effort = sum(effort)) %>%
  mutate(cpue = pcod_catch / effort) %>%
  mutate(version = "Depth <= 350 & new localities")
```

We can see that our version of the key locality commercial CPUE dataset that seeks to
replicate the last research document is nearly identical. We
believe it is slightly different, mostly for 5CD, because we used the true fishing years
whereas the last research document used an older (slightly incorrect) definition of fishing years for
consistency with a previous assessment. This version of commercial CPUE sums the catch
the Pacific Cod in each fishing year and divides that by the summed effort
across the entire bottom trawl fleet regardless of species caught or targeted.

```{r cpue-historic-paul, fig.cap="Replicating the CPUE from the last research document."}
# The data from the last research document:
paul <- read.csv(here::here("data/cpue/Starr_2013_CPUE.csv"), stringsAsFactors = FALSE) %>%
  rename(year = FYear, area = Area, cpue = CPUE) %>%
  filter(Analysis == "AD") %>%
  select(-Analysis) %>%
  mutate(version = "Forrest et al. 2015")

# Compare:
bind_rows(d_resdoc_2015, paul) %>%
  ggplot(aes(year, cpue, colour = version)) +
  facet_wrap(~area) +
  geom_line() +
  theme_pbs() +
  ylab("CPUE (kg / hr)") +
  labs(colour = "Version") + xlab("")
```

When we compare the four versions of CPUE we created we see that adding the new
localities has a very minor effect and adding the deeper fishing events has
a moderate effect in all areas except 5CD (Figure
\@ref(fig:cpue-historic-bridging-plot)).

```{r cpue-historic-bridging-plot, fig.cap="Bridging analysis for CPUE with new localities and new depth threshold."}
# Plot all of the raw CPUE versions:
cpue_new <- bind_rows(
  d_depth_350,
  d_depth_new_loc,
  d_depth_350_new_loc
)
cpue_reconstructed <- d_resdoc_2015 %>%
  rename(cpue_reconstructed = cpue) %>%
  select(area, year, cpue_reconstructed)

left_join(cpue_new, cpue_reconstructed) %>%
  ggplot(aes(year, cpue, colour = version)) +
  facet_grid(area~
    factor(version, levels =
        c("New localities", "Depth <= 350",
          "Depth <= 350 & new localities")), scales = "free_y") +
  geom_line() +
  geom_line(aes(y = cpue_reconstructed), lty = 2, col = "grey50") +
  theme_pbs() +
  guides(colour = FALSE) + xlab("") + ylab("CPUE (kg / hr)")
```

```{r save-cpue-data}
bind_rows(cpue_new, d_resdoc_2015) %>%
  saveRDS(file = here::here("data/pcod-cpue-bridging.rds"))
```

# Commercial CPUE index standardization

We can fit an index standardization model to account for the effects of depth,
month, and locality on the commercial CPUE times series. There are insufficient
older records with vessel and latitude associated with them to include them in
a model (Figure \@ref(fig:cpue-latitude-vessel-prop)).

```{r cpue-latitude-vessel-prop, fig.cap="The proportion of missing vessel and latitude for catch and effort records through time.", fig.asp=0.3}
# Can we use vessel and latitude?
g <- group_by(d_all, year, trip_id, fishing_event_id) %>%
  summarize(vessel = vessel[[1]]) %>%
  group_by(year) %>%
  summarise(prop_na = sum(is.na(vessel)) / n()) %>%
  ggplot(aes(year, prop_na)) + geom_point() +
  ylab("Proportion missing vessel ID") + xlab("")

g2 <- group_by(d_all, year, trip_id, fishing_event_id) %>%
  summarize(latitude = latitude[[1]]) %>%
  group_by(year) %>%
  summarise(prop_na = sum(is.na(latitude)) / n()) %>%
  ggplot(aes(year, prop_na)) + geom_point() +
  ylab("Proportion missing latitude") + xlab("")

cowplot::plot_grid(g, g2)
```

```{r cpue-glmm-first-filter}
raw_dat <- d_all %>%
  filter(!is.na(locality_description)) %>%
  # filter(locality_description %in% union(new_locality_2018, key_locality) |
  #     (year <= 1967 & (specific_area == "5A" | specific_area == "5B")) |
  #     area == "3CD") %>%
  filter(best_depth_m <= 350, best_depth_m >= 25) %>%
  filter(year <= 1995)

# Remove everything except for letters in the localities
# This makes it easier to plot the locality coefficients later:
raw_dat <-
  mutate(raw_dat, locality_desc = gsub(" ", "", locality_description)) %>%
  mutate(locality_desc = gsub("\\/", "", locality_desc)) %>%
  mutate(locality_desc = gsub("'", "", locality_desc)) %>%
  mutate(locality_desc = gsub(">", "", locality_desc)) %>%
  mutate(locality_desc = gsub("\\(", "", locality_desc)) %>%
  mutate(locality_desc = gsub("\\)", "", locality_desc)) %>%
  mutate(locality_desc = gsub("\\-", "", locality_desc)) %>%
  mutate(locality_desc = gsub("\\.", "", locality_desc)) %>%
  mutate(locality_desc = gsub("[0-9]", "", locality_desc))
```

After removing fishing events deeper than 350m and those that did not occur in the key Pacific Cod localities, we further removed fishing events that were missing a locality. This mostly occurs in the 1950s and early 1960s in area 5AB but only removes `r sum(is.na(raw_dat$locality_desc))` fishing events or `r round(100*sum(is.na(raw_dat$locality_desc)) / nrow(raw_dat), 2)`% of the total fishing events.

We then condensed the dataset down to create a column for Pacific Cod catch,
total hours fished, depth, month, and locality. However, prior to 1991, fishing
events were 'rolled up' into trips in the groundfish databases. We can clearly
see this in the data (Figure \@ref(fig:cpue-plot-effort-fe)). As a result, in order
to treat the timeseries consistently in the historical and recent decades, we
conducted the rest of our analysis on commercial CPUE at the trip level. To do
that we condensed the fishing event level data in 1991 and after into trips.
There is only ever a single locality and month in the database per trip, but
the depth has to be summarized in some way. We chose to summarize it as the
mean of the log depth. Furthermore, we removed all fishing events in 1991 and
after that were longer than six hours since these longer events are likely data
entry errors (see the red line after 1990 in (Figure
\@ref(fig:cpue-plot-effort-fe)).

```{r cpue-make-fe-data}
# Main dataset for model fitting:
out <- raw_dat %>% group_by(year, area, trip_id, fishing_event_id) %>%
  summarize(
    spp_catch = sum(ifelse(species_code == "222", total, 0)),
    hours_fished = hours_fished[[1]],
    depth = best_depth_m[[1]],
    month = month[[1]],
    locality = paste0("-", locality_desc[[1]]) # - is for formatting for easy coefficient plotting
  ) %>% ungroup()
```

```{r cpue-plot-pcod-dist-function}
plot_pcod_dist <- function(dat, y, ylab = "", title = "") {
  ggplot(dat, aes_string("as.factor(year)", y = y)) +
    geom_boxplot(outlier.size = 0.3, outlier.alpha = 0.5) +
    scale_y_log10(breaks = c(0.1, 1, 10, 100, 1000, 10000),
      labels = scales::comma) +
    scale_x_discrete(breaks = seq(1950, 2030, 5)) +
    theme_pbs() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
    facet_wrap(~area) + xlab("") + ylab(ylab) +
    ggtitle(title)
}
```

```{r cpue-plot-effort-fe, fig.cap="The distribution of fishing effort by year through time. Note that prior to 1991 the fishing events are rolled up to a trip level. The horizontal red line illustrates the five hour threshold that was used to remove erroneous fishing events in 1991 and after."}
plot_pcod_dist(out, y = "hours_fished", ylab = "Effort (hr)",
  title = "Effort, all fishing events (trips in older years)") +
  geom_hline(yintercept = 5, col = "red")
out <- out %>%
  filter(year < 1991 | year >= 1991 & hours_fished <= 5)
```

```{r cpue-trip-dataset}
# Main dataset at the trip level:
out_trip <- out %>% group_by(year, area, trip_id) %>%
  summarize(
    spp_catch = sum(spp_catch),
    hours_fished = sum(hours_fished),
    depth = mean(depth),
    mean_log_depth = mean(log(depth)),
    month = month[[1]],
    locality = locality[[1]],
    n_month = length(unique(month)),
    n_locality = length(unique(locality))
  ) %>% ungroup()
stopifnot(all(out_trip$n_month == 1))
stopifnot(all(out_trip$n_locality == 1))
```

We can look at the distribution of catch, effort, and CPUE for this trip-level
dataset (Figure \@ref(fig:cpue-dist-plots-catch-positive) through \@ref(fig:cpue-dist-plots-cpue-positive)).

```{r cpue-dist-plots-catch-positive, fig.cap="The distribution of Pacific Cod catch by year through time for trips that reported catching Pacific Cod."}
g1_dist <- plot_pcod_dist(filter(out_trip, spp_catch > 0),
  y = "spp_catch",
  ylab = "Catch (kg)",
  title = "Catch, positive trips")
g1_dist
```

```{r cpue-dist-plots-effort-positive, fig.cap="The distribution of effort by year through time for trips that reported catching Pacific Cod."}
g2_dist <- plot_pcod_dist(filter(out_trip, spp_catch > 0),
  y = "hours_fished",
  ylab = "Effort (hours)",
  title = "Effort, positive trips")
g2_dist
```


```{r cpue-dist-plots-effort-all, fig.cap="The distribution of effort by year through time across all bottom trawl trips."}
g3_dist <- plot_pcod_dist(out_trip, y = "hours_fished",
  ylab = "Effort (hours)",
  title = "Effort, all trips")
g3_dist
```

```{r cpue-dist-plots-cpue-positive, fig.cap="The distribution of Pacific Cod commercial CPUE by year through time for trips that reported catching Pacific Cod."}
g4_dist <- plot_pcod_dist(filter(out_trip, spp_catch > 0),
  y = "spp_catch/hours_fished",
  ylab = "CPUE (kg/hr)",
  title = "CPUE, positive trips")
g4_dist
```

\clearpage

We can also look at the distribution of fished depth through time (Figure
\@ref(fig:cpue-plot-depth-distributions-positive), \@ref(fig:cpue-plot-depth-distributions-all)). We can see a deepening of the trawl fishing after
the early 1990s across all fishing trips and for just those fishing trips that
caught Pacific Cod.

```{r cpue-plot-depth-distributions-positive, fig.cap="The distribution of average trip fishing for trips that caught Pacific Cod. Note the deepening in 3CD and 5AB."}
plot_pcod_dist(filter(out_trip, spp_catch > 0),
  y = "exp(mean_log_depth)",
  ylab = "Mean depth",
  title = "Mean depth, positive trips")
```

```{r cpue-plot-depth-distributions-all, fig.cap="The distribution of average trip fishing for trips across all trips. Note the deepening in 3CD and 5AB."}
plot_pcod_dist(out_trip,
  y = "exp(mean_log_depth)",
  ylab = "Mean depth",
  title = "Mean depth, all trips")
```

We combined a number of localities with less than 100 total trips that caught
Pacific Cod through time into a single 'minor locality' category so that random
effects could be easily estimated for all localities. This is needed, despite
the above key localitys approach, because of the addition of 3CD and the
inclusion of all catch before 1967 in 5AB.

```{r, cpue-localities-before-filter, fig.cap="The number of positive trips for Pacific Cod across localities initially included in the data set. Key localities for 5AB and 5CD (except before 1967) and without a locality filter on 3CD (this could be changed).", fig.asp=1.3}
depth_bands <- c(seq(25, 150, 25), 200, 350)
out_trip$year_factor <- as.factor(out_trip$year)
out_trip$month <- as.factor(out_trip$month)
out_trip$locality <- as.factor(out_trip$locality)
out_trip <- out_trip %>%
  mutate(pos_catch = ifelse(spp_catch > 0, 1, 0),
    depth_bin = gfplot:::factor_bin_clean(depth, depth_bands)
)

g1 <- group_by(out_trip, area, locality) %>%
  summarize(pos_catch_tot = sum(pos_catch)) %>%
  ggplot(aes(locality, pos_catch_tot)) + geom_col() +
  ylab("") + xlab("Positive trips") +
  facet_wrap(~area, scales = "free") + coord_flip() +
  ggtitle("Before locality combining")
g1
```

```{r, cpue-localities-after-filter, fig.cap="The number of positive trips for Pacific Cod across localities after grouping localities with less than 100 positive trips into a new category 'minorlocality'.", fig.asp=1.1}
small_localities <- group_by(out_trip, area, locality) %>%
  summarize(pos_catch_tot = sum(pos_catch)) %>%
  filter(pos_catch_tot < 100) %>%
  arrange(area, -pos_catch_tot) %>%
  ungroup()

# small_localities %>%
#   knitr::kable(format = "pandoc")

out_trip <- mutate(out_trip, locality = as.character(locality)) %>%
  mutate(locality = ifelse(locality %in% small_localities$locality,
    "-minorlocality", locality)) %>%
  mutate(locality = as.factor(locality))

g2 <- group_by(out_trip, area, locality) %>%
  summarize(pos_catch_tot = sum(pos_catch)) %>%
  ggplot(aes(locality, pos_catch_tot)) + geom_col() +
  facet_wrap(~area, scales = "free") +
  ylab("") + xlab("Positive trips") +
  coord_flip() +
  ggtitle("After locality combining")
g2

# cowplot::plot_grid(g1, g2, ncol = 1)
```

We can also look at the catch by month and depth bin (Figure \@ref(fig:month-depth-catch)).

```{r cpue-month-depth-catch, fig.cap="Summed catch across all years by month and depth bin. The 200m depth bin includes depths up to 350m.", fig.asp=1}
g1 <- group_by(out_trip, area, month) %>%
  summarise(catch = sum(spp_catch)) %>%
  ggplot(aes(month, catch)) + geom_point() +
  facet_wrap(~area, scales = "free_y")

g2 <- group_by(out_trip, area, depth_bin) %>%
  summarise(catch = sum(spp_catch)) %>%
  ggplot(aes(depth_bin, catch)) + geom_point() +
  facet_wrap(~area, scales = "free_y")

cowplot::plot_grid(g1, g2, ncol = 1)
```

We will fit a standardization model with a quadratic effect for depth and
random intercepts for month and locality. Details to follow. This analysis renders a similar shape to fitting a GLM with factors for depth bin, month, and locality, but lets us produce a CPUE timeseries at an average depth, average month, and average locality while integrating over the uncertainty in the month- and locality-specific estimates. It is fit in TMB as a delta-lognormal model --- binary logistic regression estimate the probability of a trip catching Pacific Cod and a linear regression fit to log CPUE estimates the expected CPUE given that some Pacific Cod was caught. The two are combined by multiplying the probability of a positive event by the expected value if a positive event occurs. Standard errors are then calculated in log space on the combined value using the automatic Delta method built into TMB.

TODO: I can plot out the coefficients but I haven't adopted the code yet to work with the random intercept version.

```{r cpue-standardize-depth}
mean_log_pcod_depth <- mean(filter(out_trip, pos_catch == 1)$mean_log_depth)
sd_log_pcod_depth <- sd(filter(out_trip, pos_catch == 1)$mean_log_depth)
# round(exp(mean_log_pcod_depth), 0)

out_trip <- mutate(out_trip,
  mean_log_depth_scaled = (mean_log_depth - mean_log_pcod_depth) / sd_log_pcod_depth,
  mean_log_depth_scaled2 = mean_log_depth_scaled^2
)

out_trip$depth_bin <- relevel(out_trip$depth_bin, ref = "075")
out_trip$month <- relevel(out_trip$month, ref = "5")
```

```{r cpue-fit-glmm-models}
# areas <- unique(out_trip$area)
areas <- c("5ABCD", "3CD")
formulas <- data_frame(
  formula = c(
    "year_factor",
    "year_factor + depth_bin",
    "year_factor + month",
    "year_factor + (1 | locality)",
    "year_factor + depth_bin + month + (1 | locality)"
  ),
  formula_version = c(
    "Unstandardized",
    "Depth",
    "Month",
    "Locality",
    "Full standardization"
  )
)
torun <- expand.grid(formula = formulas$formula, area = areas, stringsAsFactors = FALSE)
torun <- inner_join(torun, formulas, by = "formula") # to get formula_version added

if (!file.exists(here::here("data/generated/cpue-models-re.rds"))) {
  m_re <- plyr::mlply(torun, function(formula, area, formula_version) {
    df <- out_trip[out_trip$area == area, , drop = FALSE]
    message("Fitting area ", area, " and model ", formula)
    gfplot:::fit_cpue_index_re(df,
      formula_binomial = as.formula(paste("pos_catch ~", formula)),
      formula_lognormal =
        as.formula(paste("log(spp_catch / hours_fished) ~", formula))
    )
  })
  readr::write_rds(m_re, here::here("data/generated/cpue-models-re.rds"))
} else {
  m_re <- readr::read_rds(here::here("data/generated/cpue-models-re.rds"))
}
predictions_re <- plyr::ldply(m_re, predict_cpue_index)
saveRDS(predictions_re,
  file = here::here("data/generated/cpue-re-predictions.rds")
)
```

\clearpage

```{r cpue-plot-glmm-standardizations, fig.cap="The binomial and lognormal estimates of standardized CPUE (colours) compared with the unstandardized CPUE time series (black). The first 3 columns illustrate the effect of the individual predictors or random intercepts and the last column combines all 3 elements into a single model. Shaded ribbons illustrates the 95 percent confidence intervals.", fig.asp=1.2}
unstandardized <- predictions_re %>%
  filter(formula_version == "Unstandardized") %>%
  rename(est_unstandardized = est, lwr_unstandardized = lwr, upr_unstandardized = upr) %>%
  select(year, area, model, est_unstandardized, lwr_unstandardized, upr_unstandardized)

plot_re_predictions <- function(model_version = "Combined") {
  predictions_re %>%
    filter(formula_version != "Unstandardized") %>%
    left_join(unstandardized, by = c("area", "year", "model")) %>%
    filter(model == model_version) %>%
    mutate(formula_version = gsub("\\+ ", " ", formula_version)) %>%
    mutate(formula_version =
        gsub("Full standardization", "All variables", formula_version)) %>%
    ggplot(aes(year, est, ymin = upr, ymax = lwr,
      fill = area)) +
    geom_line(aes(y = est_unstandardized), colour = "grey30", lty = 1) +
    ggplot2::geom_ribbon(
      aes(ymin = lwr_unstandardized, ymax = upr_unstandardized),
      fill = "#00000030") +
    ggplot2::geom_ribbon(alpha = 0.4) +
    geom_line(aes(colour = area)) +
    theme_pbs() +
    facet_grid(area~formula_version, scales = "free_y") +
    labs(y = "CPUE (kg/hour)", x = "") +
    ylim(0, NA) +
    geom_vline(xintercept = 1996, lty = 2, col = "grey60") +
    geom_vline(xintercept = 1991, lty = 2, col = "grey80") +
    guides(colour = FALSE, fill = FALSE) +
    ggtitle(model_version)
}
g_binomial <- plot_re_predictions("Binomial")
g_lognormal <- plot_re_predictions("Lognormal")
cowplot::plot_grid(g_binomial, g_lognormal, ncol = 1)
```

\clearpage

```{r pue-plot-glmm-standardizations-combined, fig.cap="The unconditional combined estimate of standardized CPUE (colours) compared with the unstandardized CPUE time series (black). The first 3 columns illustrate the effect of the individual predictors or random intercepts and the last column combines all 3 elements into a single model."}
plot_re_predictions("Combined")
```

```{r cpue-comparison-arithmetic, fig.cap="A comparison of the arithmetic raw CPUE as illustrated earlier in the document (reconstructed with additional depth and localities) compared with the GLMM standardized mean CPUE. The upper version shows the unskilled values and the lower version shows the values scaled by dividing them by their geometric mean.", fig.asp=1}
glmm_standardized <- predictions_re %>%
  filter(formula_version == "Full standardization" & model == "Combined") %>%
  select(year, area, est, lwr, upr) %>%
  rename(cpue = est) %>%
  mutate(version = "GLMM standardized mean CPUE") %>%
  as_tibble()

cpue_comparison <- d_depth_350_new_loc %>% select(-pcod_catch, -effort) %>%
  mutate(version = paste("Forrest et al. 2015\n+", version)) %>%
  filter(!area %in% c("5AB", "5CD")) %>%
  bind_rows(glmm_standardized)

g_cpue_comparison <- cpue_comparison %>%
  ggplot(aes(year, cpue)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = version), alpha = 0.5) +
  geom_line(aes(colour = version)) +
  facet_wrap(~area) +
  labs(colour = "Version", fill = "Version") +
  ggtitle("Unscaled CPUE times series") +
  ylab("CPUE (kg / hr)") +
  xlab("")

g_cpue_comparison2 <- cpue_comparison %>%
  group_by(version, area) %>%
  mutate(geo_mean = exp(mean(log(cpue)))) %>%
  mutate(upr = upr/geo_mean, lwr = lwr/geo_mean, cpue = cpue/geo_mean) %>%
  ggplot(aes(year, cpue)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = version), alpha = 0.5) +
  geom_line(aes(colour = version)) +
  facet_wrap(~area) +
  labs(colour = "Version", fill = "Version") +
  ggtitle("Scaled to same geometric mean") +
  ylab("Proportion of geometric mean CPUE") +
  xlab("")

cowplot::plot_grid(g_cpue_comparison, g_cpue_comparison2, ncol = 1)
```

# Post-1995 CPUE

Extract the data from our databases:

```{r load-data}
if (!file.exists(here::here("data/cpue-index-dat.rds"))) {
  dcpue <- gfplot::get_cpue_index(gear = "bottom trawl", min_cpue_year = 1996)
  readr::write_rds(d, here::here("data/cpue-index-dat.rds"))
} else {
  dcpue <- readr::read_rds(here::here("data/cpue-index-dat.rds"))
}
```

Switch to a fishing year that starts April 1. I will add this option to the package shortly.

```{r}
alt_year_start_date <- "04-01" # fishing year
dcpue$year <- lubridate::year(dcpue$best_date)
dcpue <- dplyr::mutate(dcpue, .year_start_date =
    lubridate::ymd_hms(paste0(year, "-", alt_year_start_date, " 00:00:00")))
dcpue <- dplyr::mutate(dcpue, .time_diff = best_date - .year_start_date)
dcpue <- dplyr::mutate(dcpue, alt_year = ifelse(.time_diff > 0, year, year - 1L))
dcpue <- dplyr::select(dcpue, -.time_diff, -.year_start_date)
# make 'year' column mean 'fishing year'
dcpue$year <- NULL
dcpue$year <- dcpue$alt_year
dcpue$alt_year <- NULL
```

Define our fleet:

```{r define-fleet}
dfleet_5ABCD <- gfplot::tidy_cpue_index(dcpue, species_common = "pacific cod",
  year_range = c(1996, 2017), lat_range = c(48, Inf),
  min_positive_tows = 600,
  min_positive_trips = 5,
  min_yrs_with_trips = 5,
  area_grep_pattern = "^5[ABCD]+",
  lat_bin_quantiles = c(0, 1),
  depth_bin_quantiles = c(0, 1),
  gear = "BOTTOM TRAWL",
  lat_band_width = 0.2
)
dfleet_3CD <- gfplot::tidy_cpue_index(dcpue, species_common = "pacific cod",
  year_range = c(1996, 2017), lat_range = c(48, Inf),
  min_positive_tows = 600,
  min_positive_trips = 5,
  min_yrs_with_trips = 5,
  area_grep_pattern = "^3[CD]+",
  lat_bin_quantiles = c(0, 1),
  depth_bin_quantiles = c(0, 1),
  gear = "BOTTOM TRAWL",
  lat_band_width = 0.2
)
dfleet <- bind_rows(
  mutate(dfleet_5ABCD, area = "5ABCD"),
  mutate(dfleet_3CD, area = "3CD"))
```

Depth filter and effort filter:

```{r}
dfleet <- filter(dfleet, hours_fished <= 5, best_depth >= 25,
  best_depth <= 350)
```

Look at the characteristics of our fleet data set:

```{r}
# nrow(dfleet)
# sum(dfleet$pos_catch)
# length(unique(dfleet$vessel))
# sum(dfleet$spp_catch) / 1000
# hist(dfleet$best_depth)
```

Match the depth bins of Paul and change the base factor levels to specific levels (roughly the most common levels):

```{r}
depth_bands <- c(seq(25, 150, 25), 200, 325)
dfleet <- dfleet %>%
  mutate(depth_bin = gfplot:::factor_bin_clean(best_depth, depth_bands))
```

Remove a small number of localities with almost no positive fishing events so the models can be estimated well:

```{r}
large_localities <- group_by(dfleet, area, locality) %>%
  summarize(pos_catch_tot = sum(pos_catch)) %>%
  filter(pos_catch_tot >= 25) %>%
  arrange(-pos_catch_tot) %>%
  ungroup()

filter(dfleet, !locality %in% large_localities$locality)

# too few positive events so drop:
dfleet <- inner_join(dfleet, large_localities, by = c("locality", "area"))
```


```{r}
areas <- unique(dfleet$area)
formulas <- data_frame(
  formula = c(
    "year_factor",
    "year_factor + depth_bin",
    "year_factor + month",
    "year_factor + latitude",
    "year_factor + (1 | locality)",
    "year_factor + (1 | vessel)",
    "year_factor + depth_bin + month + latitude + (1 | locality) + (1 | vessel)"
  ),
  formula_version = c(
    "Unstandardized",
    "Depth",
    "Month",
    "Latitude",
    "Locality",
    "Vessel",
    "Full standardization"
  )
)
torun <- expand.grid(formula = formulas$formula, area = areas, stringsAsFactors = FALSE)
torun <- inner_join(torun, formulas, by = "formula")

if (!file.exists(here::here("data/generated/1996-cpue-models-re.rds"))) {
  m1996_re <- plyr::mlply(torun, function(formula, area, formula_version) {

    df <- dfleet[dfleet$area == area, , drop = FALSE]

    df$locality <- gfplot::f(df$locality, ref = get_most_common_level)
    df$vessel   <- gfplot::f(df$vessel, ref = get_most_common_level)
    df$latitude <- gfplot::f(df$latitude, ref = get_most_common_level)
    df$depth_bin <- relevel(as.factor(df$depth_bin), ref = "075")
    df$month <- relevel(as.factor(df$month), ref = "05")

    message("Fitting area ", area, " and model ", formula)

    gfplot:::fit_cpue_index_re(df,
      formula_binomial = as.formula(paste("pos_catch ~", formula)),
      formula_lognormal =
        as.formula(paste("log(spp_catch / hours_fished) ~", formula))
    )

  })
  readr::write_rds(m1996_re, here::here("data/generated/1996-cpue-models-re.rds"))
} else {
  m1996_re <- readr::read_rds(here::here("data/generated/1996-cpue-models-re.rds"))
}
predictions_1996_re <- plyr::ldply(m1996_re, predict_cpue_index)
saveRDS(predictions_re,
  file = here::here("data/generated/cpue-1996-re-predictions.rds")
)
```

```{r}
# predictions_1996_re %>%
#   mutate(version = "GLMM") %>%
#   mutate(area = "5ABCD") %>%
#   rename(cpue = est) %>%
#   ggplot(aes(year, cpue)) +
#   geom_ribbon(aes(ymin = lwr, ymax = upr, fill = version), alpha = 0.5) +
#   geom_line(aes(colour = version)) +
#   facet_grid(model~area, scales = "free_y") +
#   labs(colour = "Version", fill = "Version") +
#   ggtitle("Unscaled CPUE times series") +
#   ylab("CPUE (kg / hr)") +
#   xlab("")
```
